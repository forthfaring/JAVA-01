# 01





























# 02

## 1  跑一跑课上的各个例子，加深对多线程的理解 

### 对多线程和java多线程相关基础api的个人理解：

	#### 为什么需要多线程？

​	1、充分利用多核处理器的计算能力，单任务拆分给多线程执行：分工

​	2、单核处理器下也可以多任务同时处理(对用户来说)

​	3、在IO阻塞时，可以让CPU切换线程执行，充分利用CPU。

​	4、进程之间资源隔离。线程共享内存数据，通信方便。

	#### 多线程带来的问题

​	1、线程上下文切换的损耗

​	2、线程死锁问题

​	3、防止资源不足导致多线程上下文切换问题

#### 适用场景

​	1、IO阻塞等操作

​	2、任务可拆分同时执行

#### 实现原理

​	操作系统线程调度器调度线程，以线程为系统的运行单位。进程内的线程间资源共享，通信写作。



#### java Thread

* daemon

  设置新建的线程是当前线程的守护线程。当前线程运行结束，如果守护线程还在运行，则立刻结束，连finally也可能不执行。所以不能依赖守护线程做资源释放等操作。

  

* interupt

  调用的对象线程如果在运行，并不会真的打断，而是置interupt标识为true，供这个对象自己判断作为通信信号，执行对应逻辑。一般不使用。

  处于等待队列时的线程，如果调用了interupt会抛出异常

  用法：
  
  ```
  thread t1 = new Thread(()->{
  	while (!Thread.interupted()) {
  	}
  	//进行后续业务操作
  });
  t1.start;
  makeConditionSatified();
t1.interupt();
  ```

  

* thread.join

  ```
  main(){
  	thread t1...
  	t1.join();
  	//do other things
  }
  ```

  main线程wait，等待t1线程执行结束后，唤醒main线程。底层原理：适用join方法适用t1对象作为锁，然后让调用者main线程wait，t1执行结束后再JVM原理里会调用notifyAll唤醒main的等待。所以join传参数等同于wait传时间参数的效果。

* wait/notify

  使用方法：wait/notify必须在同一把同步锁内。wait会释放锁。notify执行结束后释放了锁，被唤醒的线程才有机会获取锁。
  
  等待通知机制用于线程通信。t1不满足条件就wait，t1释放锁并进入等待队列，无法获取锁。满足条件时在t2中notify t1,t1进入同步队列，t2执行结束释放锁后，t1、t2竞争获取锁。

* sleep

  线程等待，如果持有锁就不释放锁。

* volatile

  作用：修饰成员变量，保证可见性。1、对变量的修改会直接写入主存；2、使得其他线程的该变量缓存失效。3、happen-before，对指令的写入操作会使得其之前的变量对之后可见。

* synchronized

  作用：保证原子性和可见性。

  1、使用monitor实现锁机制，使得多个线程对synchronized修饰的代码块保持同步，同一时间只能有获取到锁的那个线程执行这个段代码。

  2、happen-before:前一个synchronized结束前的变量对下一个synchronized的进入可见。

* final
* 线程池相关



